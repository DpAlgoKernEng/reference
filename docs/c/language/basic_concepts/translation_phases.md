# 翻译阶段（Phases of Translation）

## 1. 概述（Overview）

**翻译阶段（Phases of Translation）** 定义了 C 编译器处理源文件的标准流程。C 标准规定编译器必须按照 8 个明确的阶段顺序处理源代码，每个阶段都有特定的转换任务。

### 核心概念

- **源文件** 经过 8 个翻译阶段最终转换为**可执行程序**
- 实际实现可能合并多个阶段或采用不同处理方式，只要最终行为符合标准
- 各阶段之间存在严格顺序依赖，前一阶段的输出是后一阶段的输入

### 翻译阶段概览

| 阶段 | 主要任务 |
|------|----------|
| 阶段 1 | 字符集映射、三字符组替换（C23 前） |
| 阶段 2 | 行拼接（反斜杠续行） |
| 阶段 3 | 词法分析、注释替换 |
| 阶段 4 | 预处理执行 |
| 阶段 5 | 字符集转换 |
| 阶段 6 | 字符串字面量拼接 |
| 阶段 7 | 编译（语法语义分析） |
| 阶段 8 | 链接 |

## 2. 来源与演变（Origin and Evolution）

### 标准演变

| 标准 | 主要变更 |
|------|----------|
| C89/C90 | 确立 8 阶段翻译模型，包含三字符组支持 |
| C99 | 沿用既有模型 |
| C11 | 沿用既有模型，新增编码前缀相关说明 |
| C17 | 沿用既有模型 |
| C23 | 移除三字符组（Trigraph）支持 |

### 设计动机

翻译阶段的划分旨在：

1. **标准化编译过程**：确保不同编译器产生一致的翻译结果
2. **分离关注点**：将字符处理、词法分析、预处理等逻辑分离
3. **支持跨平台**：通过源字符集和执行字符集的分离，支持不同平台

### C23 重要变更

三字符组（Trigraph）在 C23 标准中被移除。此前，三字符组用于解决某些键盘无法输入特定字符的问题：

```
??=  →  #      ??(  →  [      ??/  →  \
??)  →  ]      ??'  →  ^      ??<  →  {
??>  →  }      ??!  →  |      ??-  →  ~
```

## 3. 语法与参数（Syntax and Parameters）

### 阶段 1：字符集映射

**处理内容**：
1. 将源文件的字节序列映射到**源字符集（Source Character Set）**
2. 替换操作系统相关的行结束符为换行符
3. 三字符组替换（C23 前）

**基本源字符集**包含 96 个字符：

| 类型 | 字符 |
|------|------|
| 空白字符 (5个) | 空格、水平制表符、垂直制表符、换页符、换行符 |
| 数字字符 (10个) | `0` - `9` |
| 字母字符 (52个) | `a` - `z`、`A` - `Z` |
| 标点字符 (29个) | `_ { } [ ] # ( ) < > % : ; . ? * + - / ^ & \| ~ ! = , \\ " '` |

### 阶段 2：行拼接

**处理规则**：
- 当反斜杠 `\` 出现在行尾（紧接换行符）时，删除反斜杠和换行符
- 将两个物理行合并为一个逻辑行
- **单次扫描操作**：行尾两个反斜杠后跟空行不会合并三行

**未定义行为**：
- 非空源文件在此阶段后不以换行符结尾

### 阶段 3：词法分析

**处理内容**：
1. 将源文件分解为：
   - 注释
   - 空白字符序列
   - 预处理记号（Preprocessing Tokens）

**预处理记号类型**：

| 类型 | 示例 |
|------|------|
| 头文件名 | `<stdio.h>`、`"myfile.h"` |
| 标识符 | `main`、`printf` |
| 预处理数字 | `123`、`3.14`、`0xE+foo`（可能无效） |
| 字符常量/字符串字面量 | `'a'`、`"hello"` |
| 运算符和标点 | `+`、`<<=`、`<%`、`##` |
| 其他非空白字符 | 不符合其他类别的单个字符 |

**重要规则**：
- 每个注释被替换为**单个空格字符**
- 换行符被保留
- 非换行空白序列是否折叠为单个空格由实现定义

**最大匹配原则（Maximal Munch）**：
- 解析预处理记号时，总是选择能构成有效记号的最长字符序列

### 阶段 4：预处理

**处理内容**：
1. 执行预处理器
2. 处理 `#include` 指令（递归执行阶段 1-4）
3. 移除所有预处理指令

### 阶段 5：字符集转换

**处理内容**：
- 将字符常量和字符串字面量中的字符和转义序列从源字符集转换为**执行字符集（Execution Character Set）**
- 执行字符集必须保证基本源字符集的 96 个字符都有单字节表示

**实现定义行为**：
- 如果转义序列指定的字符不在执行字符集中，结果由实现定义
- 但保证不会产生空（宽）字符

### 阶段 6：字符串拼接

**处理内容**：
- 相邻的字符串字面量被拼接

### 阶段 7：编译

**处理内容**：
- 对记号进行语法和语义分析
- 翻译为翻译单元（Translation Unit）

### 阶段 8：链接

**处理内容**：
- 收集翻译单元和库组件
- 解析外部引用
- 生成包含执行环境所需信息的程序映像

## 4. 底层原理（Underlying Principles）

### 阶段顺序的必要性

```
源代码
    │
    ▼ 阶段 1: 字符集标准化
    │
    ▼ 阶段 2: 行拼接（支持宏定义跨行）
    │
    ▼ 阶段 3: 词法分析（注释→空格）
    │
    ▼ 阶段 4: 预处理（展开宏、处理指令）
    │
    ▼ 阶段 5: 字符集转换（源→执行字符集）
    │
    ▼ 阶段 6: 字符串拼接
    │
    ▼ 阶段 7: 编译
    │
    ▼ 阶段 8: 链接
    │
执行程序
```

### 为什么注释替换在预处理之前？

注释在阶段 3 被替换为空格，而预处理在阶段 4 执行。这种设计意味着：

1. 宏无法创建注释
2. 注释无法跨越 `#include` 边界延续
3. 注释内容不参与宏展开

### 为什么字符串拼接在预处理之后？

字符串拼接在阶段 6 执行，晚于预处理（阶段 4）。这允许：

```c
#define PREFIX "Hello"
#define SUFFIX " World"
// 无法通过宏直接拼接 PREFIX 和 SUFFIX
// 因为拼接发生在宏展开之后
```

### 编译器选项控制

GCC/Clang 提供选项控制阶段 5 的字符集转换：

| 选项 | 作用 |
|------|------|
| `-finput-charset=charset` | 指定源字符集编码 |
| `-fexec-charset=charset` | 指定窄字符串/字符的执行字符集 |
| `-fwide-exec-charset=charset` | 指定宽字符串/字符的执行字符集 |

## 5. 使用场景（Use Cases）

### 行拼接的实际应用

行拼接常用于：
- 长宏定义的可读性
- 长字符串的分行书写

```c
#define LONG_MACRO(a, b, c) \
    do {                    \
        process(a);         \
        process(b);         \
        process(c);         \
    } while(0)
```

### 最大匹配原则的影响

最大匹配原则可能导致意外的解析结果：

```c
int y = x+++z;    // 解析为 x++ + z，而非 x + ++z
int y = x-----z;  // 错误：解析为 x-- -- -z，无效语法
```

### 头文件名记号的限制

`<...>` 形式的头文件名仅在以下位置被识别：
- `#include` 指令
- `#embed` 指令（C23 起）
- `__has_include` 表达式（C23 起）
- `#pragma` 指令中的实现定义位置

```c
#define MACRO_1 1
#define MACRO_2 2
#define MACRO_3 3
// <MACRO_2> 在此处不作为头文件名，因此合法
#define EXPR (MACRO_1 <MACRO_2> MACRO_3)
```

### 字符编码注意事项

跨平台开发时需注意：
- 源文件编码（阶段 1 输入）
- 执行环境编码（阶段 5 输出）
- 宽字符编码

## 6. 代码示例（Examples）

### 行拼接示例

```c
#include <stdio.h>

#define PUTS p\
u\
t\
s
/* 行拼接在阶段 2，宏记号化在阶段 3，展开在阶段 4
 * 因此以上等价于 #define PUTS puts
 */

int main(void)
{
    /* 使用行拼接调用 puts */
    PUT\
    S\
    ("Output ends here\\
    0Not printed" /* 行拼接后，剩余反斜杠转义了 0，
                   * 使字符串提前结束 */
    );

    return 0;
}
```

**输出**：
```
Output ends here
```

### 最大匹配原则示例

```c
#include <stdio.h>

int main(void)
{
    int foo = 1;

    // 错误：0xE+foo 被解析为预处理数字，无效
    // int bar = 0xE+foo;

    // 正确：注释展开为空格，变为 0xE + foo
    int bar = 0xE/*Comment*/+foo;

    // 正确：显式分隔
    int baz = 0xE + foo;

    int pub = bar+++baz;        // 正确：bar++ + baz
    int ham = bar++-++baz;      // 正确：bar++ - ++baz

    // 错误：bar+++++baz 解析为 bar++ ++ +baz
    // int qux = bar+++++baz;

    // 正确：注释分隔
    int qux = bar+++/*comment*/++baz;  // bar++ + ++baz

    printf("bar=%d, baz=%d, pub=%d, ham=%d, qux=%d\n",
           bar, baz, pub, ham, qux);
    return 0;
}
```

### 字符串拼接示例

```c
#include <stdio.h>

int main(void)
{
    // 阶段 6 字符串拼接
    char* str = "Hello, " "World!";

    // 等价于
    char* str2 = "Hello, World!";

    printf("%s\n%s\n", str, str2);
    return 0;
}
```

**输出**：
```
Hello, World!
Hello, World!
```

### 常见错误：文件末尾无换行

```c
/* 文件内容（无末尾换行） */
int main(void) { return 0; }/* 文件到此结束，无换行符 */
```

**说明**：根据标准，非空源文件不以换行符结尾属于未定义行为。虽然大多数编译器会接受，但可能产生警告。

### 常见错误：反斜杠续行的陷阱

```c
#include <stdio.h>

int main(void)
{
    // 行尾反斜杠会将下一行合并
    // 注意：下一行即使是注释也会被合并
    int x = 1; \
    int y = 2;  // 这行会被合并到上一行！

    printf("x=%d, y=%d\n", x, y);

    // 正确做法：避免在非续行场景使用行尾反斜杠
    return 0;
}
```

## 7. 总结（Summary）

### 核心要点

1. **8 个翻译阶段**：定义了从源文件到可执行程序的标准处理流程
2. **顺序严格**：每个阶段依赖前一阶段的输出
3. **实现灵活性**：编译器可合并阶段，只要行为符合标准
4. **C23 变更**：移除了三字符组支持

### 阶段关键操作

| 阶段 | 关键操作 | 重要影响 |
|------|----------|----------|
| 1 | 字符集映射 | 支持多种编码的源文件 |
| 2 | 行拼接 | 支持宏定义跨行 |
| 3 | 词法分析 | 注释→空格，最大匹配原则 |
| 4 | 预处理 | 宏展开、文件包含 |
| 5 | 字符集转换 | 源编码→执行编码 |
| 6 | 字符串拼接 | 相邻字符串合并 |
| 7 | 编译 | 语法语义分析 |
| 8 | 链接 | 解析外部引用 |

### 学习建议

1. 理解各阶段的顺序和处理内容
2. 注意最大匹配原则对代码解析的影响
3. 跨平台开发时注意字符编码问题
4. 避免依赖未定义行为（如文件末尾换行）

### 参考资料

- C23 标准 (ISO/IEC 9899:2024): 5.1.1.2 Translation phases, 5.2.1 Character sets, 6.4 Lexical elements
- C17 标准 (ISO/IEC 9899:2018): 5.1.1.2 Translation phases (p: 9-10), 5.2.1 Character sets (p: 17), 6.4 Lexical elements (p: 41-54)
- C11 标准 (ISO/IEC 9899:2011): 5.1.1.2 Translation phases (p: 10-11), 5.2.1 Character sets (p: 22-24), 6.4 Lexical elements (p: 57-75)
- C99 标准 (ISO/IEC 9899:1999): 5.1.1.2 Translation phases (p: 9-10), 5.2.1 Character sets (p: 17-19), 6.4 Lexical elements (p: 49-66)
- C89/C90 标准 (ISO/IEC 9899:1990): 2.1.1.2 Translation phases, 2.2.1 Character sets, 3.1 Lexical elements