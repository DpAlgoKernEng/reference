# 生命周期（Lifetime）

## 1. 概述（Overview）

每个对象和引用都有**生命周期（lifetime）**，这是一个运行时属性：对于任何对象或引用，程序的执行中有一个时刻其生命周期开始，也有一个时刻其生命周期结束。

### 核心概念

生命周期决定了对象何时可以安全地被访问。在生命周期外访问对象会导致未定义行为。

### 生命周期与存储期的关系

对象的生命周期等于或嵌套在其存储的生命周期内。参见存储期（storage duration）。

## 2. 来源与演变（Origin and Evolution）

### 标准演变

| 标准 | 主要变更 |
|------|----------|
| C++98 | 定义基础生命周期规则 |
| C++11 | 引入 Lambda 表达式、`std::initializer_list` 相关临时对象 |
| C++17 | 引入临时对象物化概念、透明可替换性、`std::launder`、`std::byte` 提供存储 |
| C++20 | `[[no_unique_address]]` 对透明可替换性的影响 |
| C++23 | 范围 for 循环中临时对象生命周期扩展 |

### 重要缺陷报告

| 缺陷报告 | 变更 |
|----------|------|
| CWG 2256 | 统一了平凡可析构对象与其他对象的生命周期结束规则 |
| CWG 2012 | 引用生命周期从初始化开始，而非匹配存储期 |
| P0137R1 | 在 `unsigned char` 数组中创建对象不再重用其存储 |
| P0593R6 | 伪析构函数调用会销毁对象 |
| P1971R0 | 移除了 const 成员或引用成员阻止透明可替换的限制 |

## 3. 语法与参数（Syntax and Parameters）

### 3.1 对象生命周期的开始

对象的生命周期在以下条件同时满足时开始：

1. 获得具有适当对齐和大小的存储
2. 初始化（如果有）完成（包括默认初始化）

**例外情况**：

| 情况 | 说明 |
|------|------|
| 联合体成员 | 只有当该成员是初始化成员或被激活时，生命周期才开始 |
| 嵌套在联合体中 | 如果包含的联合体通过平凡特殊成员函数赋值或构造，生命周期可能开始 |
| 数组对象 | 通过 `std::allocator::allocate` 分配时 |
| 隐式生命周期类型 | 某些操作隐式创建对象并开始其生命周期 |

### 3.2 对象生命周期的结束

对象的生命周期在以下情况结束时结束：

| 情况 | 说明 |
|------|------|
| 非类类型 | 对象被销毁（可能通过伪析构函数调用） |
| 类类型 | 析构函数调用开始 |
| 存储释放 | 对象占用的存储被释放或被非嵌套对象重用 |

### 3.3 引用的生命周期

引用的生命周期：
- **开始**：初始化完成时
- **结束**：如同标量对象

**注意**：被引用对象的生命周期可能在引用的生命周期结束之前结束，这会产生悬空引用。

### 3.4 成员和基类子对象

非静态数据成员和基类子对象的生命周期遵循类初始化顺序：
- 基类先于派生类
- 成员按声明顺序

## 4. 底层原理（Underlying Principles）

### 4.1 临时对象生命周期（C++17 起）

当纯右值（prvalue）被物化以用作泛左值（glvalue）时，会创建临时对象。物化发生在以下情况：

| 情况 | 说明 |
|------|------|
| 绑定引用到纯右值 | `const T& r = T()` |
| 初始化 `std::initializer_list` | 从花括号初始化列表 |
| 函数返回纯右值 | `T f() { return T(); }` |
| 创建纯右值的转换 | `T(a, b, c)` 或 `T{}` |
| Lambda 表达式 | `[=]{}` |
| 类纯右值的成员访问 | `make_pair().first` |
| 数组纯右值的转换 | 数组到指针转换或下标操作 |
| 未求值操作数 | `sizeof` 和 `typeid` |
| 丢弃值表达式 | `T();` 作为语句 |

### 4.2 临时对象的销毁

所有临时对象在评估包含其创建点的完整表达式（词法上）的最后一步销毁。如果创建了多个临时对象，则按创建相反的顺序销毁。

**例外情况**：

| 情况 | 生命周期扩展 |
|------|--------------|
| 绑定到引用 | 延长到引用的生命周期 |
| 数组初始化的默认参数 | 在下一个元素初始化前结束 |
| 结构化绑定声明（C++17 起） | 延长到声明结束 |
| 范围 for 循环（C++23 起） | 延长到循环体结束 |

### 4.3 存储重用

**平凡可析构对象**：程序不需要调用析构函数来结束其生命周期。

**非平凡可析构对象**：如果显式结束生命周期，必须在析构函数被隐式调用之前，在原位置构造一个相同类型的新对象。

```cpp
class T {};  // 平凡

struct B {
    ~B() {}  // 非平凡
};

void x() {
    long long n;  // 自动，平凡
    new (&n) double(3.14);  // 用不同类型重用，OK
}  // OK

void h() {
    B b;  // 自动，非平凡可析构
    b.~B();  // 结束生命周期
    new (&b) T;  // 错误类型：直到析构函数被调用前 OK
}  // 析构函数被调用：未定义行为
```

### 4.4 const 对象的存储重用

重用 const 完整对象的存储是未定义行为（静态、线程局部或自动存储期）：

```cpp
struct B {
    B();
    ~B();
};
const B b;  // const 静态

void h() {
    b.~B();  // 结束 b 的生命周期
    new (const_cast<B*>(&b)) const B;  // 未定义行为：尝试重用 const
}
```

### 4.5 透明可替换性

如果在另一个对象占用的地址创建新对象，原对象的所有指针、引用和名称会自动引用新对象，但仅当原对象可被新对象**透明替换**。

**透明可替换条件**：

1. 新对象的存储完全覆盖原对象占用的存储位置
2. 新对象与原对象类型相同（忽略顶层 cv 限定符）
3. 原对象不是完整 const 对象
4. 原对象和新对象都不是基类子对象或 `[[no_unique_address]]` 成员
5. 满足以下条件之一：
   - 两者都是完整对象
   - 两者都是直接子对象，且包含对象可透明替换

```cpp
struct C {
    int i;
    void f();
    const C& operator=(const C&);
};

const C& C::operator=(const C& other) {
    if (this != &other) {
        this->~C();           // *this 的生命周期结束
        new (this) C(other);  // 创建类型 C 的新对象
        f();                  // 良定义
    }
    return *this;
}
```

### 4.6 std::launder

如果不满足透明可替换条件，可以使用 `std::launder` 获取指向新对象的有效指针：

```cpp
struct A {
    virtual int transmogrify();
};

struct B : A {
    int transmogrify() override { ::new(this) A; return 2; }
};

inline int A::transmogrify() { ::new(this) B; return 1; }

void test() {
    A i;
    int n = i.transmogrify();
    // int m = i.transmogrify();  // 未定义行为
    int m = std::launder(&i)->transmogrify();  // OK
}
```

### 4.7 提供存储（C++17 起）

`unsigned char` 或 `std::byte` 数组可以为其他对象提供存储：

**条件**：
1. 数组的生命周期已开始且未结束
2. 新对象的存储完全在数组内
3. 没有嵌套数组满足这些约束

```cpp
template<typename... T>
struct AlignedUnion {
    alignas(T...) unsigned char data[max(sizeof(T)...)];
};

int f() {
    AlignedUnion<int, char> au;
    int* p = new (au.data) int;      // OK，au.data 提供存储
    char* c = new (au.data) char();  // OK，结束 *p 的生命周期
    char* d = new (au.data + 1) char();
    return *c + *d;  // OK
}
```

### 4.8 生命周期外的访问

在对象生命周期开始之前或结束之后，以下行为是未定义的：

| 行为 | 说明 |
|------|------|
| 左值到右值转换 | 读取对象值 |
| 访问非静态成员 | 成员访问 |
| 调用非静态成员函数 | 成员函数调用 |
| 绑定虚基类引用 | 引用绑定 |
| `dynamic_cast` 或 `typeid` | RTTI 操作 |

**指针的额外规则**：
- 无对象存储的指针只能 `static_cast` 到 `void*`
- 从 `void*` 转换只能到 `char*`、`unsigned char*` 或 `std::byte*`

## 5. 使用场景（Use Cases）

### 5.1 自动存储期对象

```cpp
void process() {
    std::string s = "hello";  // 生命周期开始
    // 使用 s
}  // 生命周期结束，析构函数调用
```

### 5.2 动态分配对象

```cpp
void dynamic_example() {
    int* p = new int(42);  // 生命周期开始
    std::cout << *p;
    delete p;  // 生命周期结束
}
```

### 5.3 临时对象与引用绑定

```cpp
void temp_example() {
    const std::string& ref = std::string("temp");  // 临时对象生命周期延长
    std::cout << ref;  // OK
}  // 临时对象在此销毁
```

### 5.4 常见陷阱

1. **悬空引用**：

```cpp
const int& dangling() {
    int local = 42;
    return local;  // 返回局部变量的引用
}  // local 生命周期结束

void use_dangling() {
    const int& r = dangling();
    std::cout << r;  // 未定义行为
}
```

2. **存储重用与析构函数**：

```cpp
struct NonTrivial {
    ~NonTrivial() { std::cout << "dtor\n"; }
};

void bad_reuse() {
    NonTrivial obj;
    obj.~NonTrivial();
    new (&obj) int(42);  // 不同类型
}  // 未定义行为：尝试调用 NonTrivial 的析构函数
```

3. **placement new 与自赋值**：

```cpp
struct S {
    int m;
};

void f() {
    S x{1};
    new(&x) S(x.m);  // 未定义行为：存储被重用
}
```

## 6. 代码示例（Examples）

### 基础用法

```cpp
#include <iostream>
#include <string>

class Widget {
public:
    Widget() { std::cout << "Widget created\n"; }
    ~Widget() { std::cout << "Widget destroyed\n"; }
    void use() { std::cout << "Widget used\n"; }
};

void demonstrate_lifetime()
{
    std::cout << "Entering block\n";
    {
        Widget w;  // 生命周期开始
        w.use();
    }  // 生命周期结束
    std::cout << "Exiting block\n";
}

int main()
{
    demonstrate_lifetime();
    return 0;
}
```

### 临时对象生命周期

```cpp
#include <iostream>
#include <string>

std::string create_string() {
    return std::string("temporary");
}

void demonstrate_temp()
{
    // 临时对象绑定到 const 引用，生命周期延长
    const std::string& ref = create_string();
    std::cout << "ref: " << ref << std::endl;  // OK

    // 花括号初始化列表创建临时对象
    auto list = {1, 2, 3};  // std::initializer_list<int>

    // 函数返回纯右值
    std::cout << create_string() << std::endl;  // 临时对象在语句结束销毁
}

int main()
{
    demonstrate_temp();
    return 0;
}
```

### 透明可替换

```cpp
#include <iostream>
#include <new>

class Buffer {
public:
    int data[10];

    void reinitialize() {
        this->~Buffer();           // 结束生命周期
        new (this) Buffer();       // 透明替换
    }
};

int main()
{
    Buffer buf;
    buf.data[0] = 42;

    std::cout << "Before: " << buf.data[0] << std::endl;

    buf.reinitialize();

    std::cout << "After: " << buf.data[0] << std::endl;  // 可预测值

    return 0;
}
```

### 提供存储

```cpp
#include <iostream>
#include <new>
#include <cstddef>

template<typename T>
class Storage {
    alignas(T) std::byte data[sizeof(T)];

public:
    template<typename... Args>
    void construct(Args&&... args) {
        new (data) T(std::forward<Args>(args)...);
    }

    T& get() {
        return *reinterpret_cast<T*>(data);
    }

    void destroy() {
        get().~T();
    }
};

int main()
{
    Storage<std::string> storage;
    storage.construct("Hello, World!");

    std::cout << storage.get() << std::endl;

    storage.destroy();

    return 0;
}
```

### 常见错误及修正

```cpp
#include <iostream>
#include <string>

/* 错误：返回局部变量引用 */
const std::string& bad_return_ref() {
    std::string local = "local";
    return local;  // 悬空引用
}

/* 正确：按值返回 */
std::string good_return_value() {
    std::string local = "local";
    return local;  // 返回值优化
}

/* 错误：const 对象存储重用 */
void bad_const_reuse() {
    const int c = 42;
    // new (const_cast<int*>(&c)) int(100);  // 未定义行为
}

/* 正确：非 const 对象存储重用 */
void good_reuse() {
    int n = 42;
    new (&n) int(100);  // OK，int 是平凡类型
    std::cout << n << std::endl;
}

/* 错误：生命周期外访问 */
void bad_access() {
    int* p = nullptr;
    {
        int local = 42;
        p = &local;
    }  // local 生命周期结束
    // std::cout << *p;  // 未定义行为
}

/* 正确：确保生命周期覆盖使用 */
int* good_allocate() {
    return new int(42);
}

/* 错误：范围 for 中临时对象生命周期 */
void bad_range_for() {
    // std::vector<std::string> get_strings();
    // for (auto& s : get_strings()) {  // C++23 前：悬空引用
    //     std::cout << s;
    // }
}

/* C++23 起：正确 */
void good_range_for() {
    // std::vector<std::string> get_strings();
    // for (auto& s : get_strings()) {  // C++23：临时对象生命周期延长
    //     std::cout << s;
    // }
}

int main()
{
    std::cout << good_return_value() << std::endl;
    good_reuse();

    int* p = good_allocate();
    std::cout << *p << std::endl;
    delete p;

    return 0;
}
```

## 7. 总结（Summary）

### 核心要点

1. **生命周期定义**：对象存在并可访问的时间段
2. **开始条件**：存储分配 + 初始化完成
3. **结束条件**：销毁或存储释放/重用
4. **临时对象**：完整表达式结束时销毁，绑定引用可延长
5. **存储重用**：注意 const 对象和非平凡析构函数的限制

### 生命周期类型对比

| 类型 | 开始 | 结束 |
|------|------|------|
| 自动存储期 | 块入口/声明点 | 块出口 |
| 静态存储期 | 程序启动 | 程序结束 |
| 线程存储期（C++11 起） | 线程启动 | 线程结束 |
| 动态分配 | `new` 返回 | `delete` 调用 |
| 临时对象 | 物化点 | 完整表达式结束 |

### 透明可替换条件

| 条件 | 说明 |
|------|------|
| 存储覆盖 | 新对象完全覆盖原对象存储 |
| 类型相同 | 忽略顶层 cv 限定符 |
| 非 const 完整对象 | 原对象不能是 const 完整对象 |
| 非特殊子对象 | 不能是基类子对象或 `[[no_unique_address]]` 成员 |

### 未定义行为

| 行为 | 说明 |
|------|------|
| 生命周期外访问 | 访问未初始化或已销毁的对象 |
| const 对象存储重用 | 重用 const 静态/线程/自动对象 |
| 析构函数调用错误 | 平凡可析构对象重用后错误调用析构 |

### C++ vs C 生命周期对比

```markdown
核心差异概览                      
┌──────────────┬───────────────────────────┬──────────────────────────┐                                                                                          
│     特性     │            C++            │            C             │                                                 
├──────────────┼───────────────────────────┼──────────────────────────┤                                                                                          
│ 对象模型     │ 完整对象模型（构造/析构） │ 简单存储模型             │                                                             
├──────────────┼───────────────────────────┼──────────────────────────┤
│ 生命周期开始 │ 存储 + 初始化完成         │ 存储 + 初始化（可选）    │
├──────────────┼───────────────────────────┼──────────────────────────┤
│ 生命周期结束 │ 析构函数开始或存储释放    │ 存储释放或重用           │
├──────────────┼───────────────────────────┼──────────────────────────┤
│ 临时对象     │ 有完整的临时对象生命周期  │ 有临时生命周期（C99 起） │
├──────────────┼───────────────────────────┼──────────────────────────┤
│ 引用         │ 有独立的生命周期          │ 无引用概念               │
├──────────────┼───────────────────────────┼──────────────────────────┤
│ 透明可替换   │ 有                        │ 无                       │
└──────────────┴───────────────────────────┴──────────────────────────┘

详细对比
1. 生命周期开始
┌──────────────┬──────────────────────────────┬────────────────────────┐
│     方面     │             C++              │           C            │
├──────────────┼──────────────────────────────┼────────────────────────┤
│ 基本条件     │ 存储分配 + 初始化完成        │ 存储分配（初始化可选） │
├──────────────┼──────────────────────────────┼────────────────────────┤
│ 构造函数     │ 构造函数完成才算开始         │ 无构造函数概念         │
├──────────────┼──────────────────────────────┼────────────────────────┤
│ 联合体成员   │ 只有被激活的成员才有生命周期 │ 类似但更简单           │
├──────────────┼──────────────────────────────┼────────────────────────┤
│ 隐式创建对象 │ C++17 起：隐式生命周期类型   │ 无此概念               │
└──────────────┴──────────────────────────────┴────────────────────────┘

// C++：构造函数完成后生命周期才开始
std::string s = "hello";  // 构造函数完成后生命周期开始

/* C：存储分配后生命周期开始 */
int x = 10;  /* 存储分配后立即开始 */

2. 生命周期结束
┌────────────┬────────────────────┬────────────────┐
│    方面    │        C++         │       C        │
├────────────┼────────────────────┼────────────────┤
│ 类类型     │ 析构函数开始时结束 │ 无             │
├────────────┼────────────────────┼────────────────┤
│ 非类类型   │ 销毁或存储释放     │ 存储释放或重用 │
├────────────┼────────────────────┼────────────────┤
│ 平凡可析构 │ 可以不调用析构函数 │ 不适用         │
└────────────┴────────────────────┴────────────────┘

// C++：析构函数开始时生命周期结束
{
    std::string s = "hello";
}  // 析构函数开始，生命周期结束

/* C：存储释放时结束 */
{
    int x = 10;
}  /* 块结束，存储释放，生命周期结束 */

3. 临时对象
┌──────────────┬──────────────────────────┬──────────────────────────────────────┐
│     方面     │           C++            │                  C                   │
├──────────────┼──────────────────────────┼──────────────────────────────────────┤
│ 概念         │ 临时对象物化（C++17 起） │ 临时生命周期（C99 起）               │
├──────────────┼──────────────────────────┼──────────────────────────────────────┤
│ 创建时机     │ 纯右值物化时             │ 非左值结构体/联合体表达式            │
├──────────────┼──────────────────────────┼──────────────────────────────────────┤
│ 结束时机     │ 完整表达式结束           │ 完整表达式结束（C11）/ 序列点（C99） │
├──────────────┼──────────────────────────┼──────────────────────────────────────┤
│ 生命周期延长 │ 绑定到 const 引用可延长  │ 不支持延长                           │
└──────────────┴──────────────────────────┴──────────────────────────────────────┘

// C++：临时对象生命周期可延长
const std::string& ref = std::string("temp");
// 临时对象生命周期延长到 ref 的生命周期结束

/* C：临时生命周期，不可延长 */
struct T { double a[4]; };
struct T f(void) { return (struct T){3.15}; }

double d = f().a[0];  /* C11: OK */
/* 但不能绑定引用延长 */

4. 引用 vs 指针
┌──────────┬────────────────┬──────────────────┐
│   方面   │    C++ 引用    │      C 指针      │
├──────────┼────────────────┼──────────────────┤
│ 生命周期 │ 有独立生命周期 │ 无（只是地址值） │
├──────────┼────────────────┼──────────────────┤
│ 悬空问题 │ 悬空引用       │ 悬空指针         │
├──────────┼────────────────┼──────────────────┤
│ 初始化后 │ 不能重新绑定   │ 可以重新赋值     │
└──────────┴────────────────┴──────────────────┘

// C++：引用有生命周期
int x = 10;
int& r = x;  // 引用的生命周期从初始化完成开始
// 引用在其生命周期内始终绑定到 x

/* C：指针只是地址 */
int x = 10;
int* p = &x;  /* p 可以随时指向其他地址 */

5. 存储重用
┌──────────────┬────────────────────────────────────────┬──────────────────┐
│     方面     │                  C++                   │        C         │
├──────────────┼────────────────────────────────────────┼──────────────────┤
│ 透明可替换   │ 有明确规则                             │ 无               │
├──────────────┼────────────────────────────────────────┼──────────────────┤
│ const 对象   │ 重用 const 静态对象是 UB               │ 类似限制         │
├──────────────┼────────────────────────────────────────┼──────────────────┤
│ std::launder │ 用于处理复杂情况                       │ 无               │
├──────────────┼────────────────────────────────────────┼──────────────────┤
│ 提供存储     │ unsigned char[]/std::byte[] 可提供存储 │ 类似但规则更简单 │
└──────────────┴────────────────────────────────────────┴──────────────────┘

// C++：透明可替换
struct C {
    int i;
    void reinit() {
        this->~C();       // 结束生命周期
        new (this) C();   // 透明替换，i 仍可通过 this 访问
    }
};

/* C：更简单的存储重用 */
struct C {
    int i;
};

void reinit(struct C* p) {
    memset(p, 0, sizeof(*p));  /* 直接重用存储 */
}

6. 生命周期外访问
┌───────────────┬──────────┬──────────┐
│     方面      │   C++    │    C     │
├───────────────┼──────────┼──────────┤
│ UB 行为       │ 定义明确 │ 定义明确 │
├───────────────┼──────────┼──────────┤
│ 指针/引用转换 │ 有限制   │ 相对宽松 │
├───────────────┼──────────┼──────────┤
│ static_cast   │ 有限制   │ 较自由   │
└───────────────┴──────────┴──────────┘

作用域类型对比（作为补充）
┌──────────────────────────────────┬──────────────────────────────┐
│               C++                │              C               │
├──────────────────────────────────┼──────────────────────────────┤
│ 块作用域                         │ 块作用域                     │
├──────────────────────────────────┼──────────────────────────────┤
│ 命名空间作用域（替代文件作用域） │ 文件作用域                   │
├──────────────────────────────────┼──────────────────────────────┤
│ 类作用域                         │ 无（结构体成员在文件作用域） │
├──────────────────────────────────┼──────────────────────────────┤
│ 函数参数作用域                   │ 函数原型作用域               │
├──────────────────────────────────┼──────────────────────────────┤
│ 模板参数作用域                   │ 无                           │
├──────────────────────────────────┼──────────────────────────────┤
│ Lambda 作用域                    │ 无                           │
├──────────────────────────────────┼──────────────────────────────┤
│ 枚举作用域                       │ 无                           │
├──────────────────────────────────┼──────────────────────────────┤
│ —                                │ 函数作用域（标签）           │
└──────────────────────────────────┴──────────────────────────────┘

关键差异总结
1. 对象模型：C++ 有完整的构造/析构生命周期，C 仅关注存储
2. 临时对象：C++ 支持生命周期延长，C 不支持
3. 引用：C++ 特有，有独立生命周期
4. 透明可替换：C++ 独有，处理复杂的存储重用场景
5. 类作用域：C++ 成员在类作用域内，C 成员在文件作用域
```

### 最佳实践

- 使用 RAII 管理资源生命周期
- 避免返回局部变量的引用或指针
- 注意临时对象的生命周期限制
- 理解 placement new 和存储重用规则
- 使用 `std::launder` 处理复杂存储重用场景

### 参考资料

- C++23 标准 (ISO/IEC 14882:2024): 6.7.3 Object lifetime [basic.life]
- C++20 标准 (ISO/IEC 14882:2020): 6.7.3 Object lifetime [basic.life]
- C++17 标准 (ISO/IEC 14882:2017): 6.8 Object lifetime [basic.life]
- C++14 标准 (ISO/IEC 14882:2014): 3 Object lifetime [basic.life]
- C++11 标准 (ISO/IEC 14882:2011): 3.8 Object lifetime [basic.life]
- C++98 标准 (ISO/IEC 14882:1998): 3.8 Object lifetime [basic.life]