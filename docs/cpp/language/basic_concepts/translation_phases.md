# 翻译阶段（Phases of Translation）

## 1. 概述（Overview）

**翻译阶段（Phases of Translation）** 定义了 C++ 编译器将源文件转换为可执行程序的标准流程。C++ 标准规定了 9 个翻译阶段，每个阶段都有特定的转换任务。

### 核心概念

- **源文件（Source Files）**：保存 C++ 程序文本的基本单元
- **翻译单元（Translation Unit）**：经过翻译阶段处理后的编译单元
- **预处理记号（Preprocessing Tokens）**：翻译阶段 3-6 中的最小词法元素
- **记号（Tokens）**：翻译阶段 7 中的最小词法元素

### 翻译流程概览

```
源文件 → [阶段1: 字符映射] → 字符序列
       → [阶段2: 行拼接] → 逻辑行
       → [阶段3: 词法分析] → 预处理记号序列
       → [阶段4: 预处理] → 展开后的记号
       → [阶段5: 字符集转换] → 编码转换
       → [阶段6: 字符串拼接] → 拼接后的字符串
       → [阶段7: 编译] → 翻译单元
       → [阶段8: 模板实例化] → 实例化单元
       → [阶段9: 链接] → 可执行程序
```

### 翻译阶段概览

| 阶段 | 主要任务 |
|------|----------|
| 阶段 1 | 源字符映射、三字符组替换（C++17 前） |
| 阶段 2 | 行拼接（反斜杠续行） |
| 阶段 3 | 词法分析、注释替换、原始字符串处理 |
| 阶段 4 | 预处理执行 |
| 阶段 5 | 确定字符串字面量编码 |
| 阶段 6 | 字符串字面量拼接 |
| 阶段 7 | 编译（语法语义分析） |
| 阶段 8 | 模板实例化 |
| 阶段 9 | 链接 |

## 2. 来源与演变（Origin and Evolution）

### 标准演变

| 标准 | 主要变更 |
|------|----------|
| C++98 | 确立 9 阶段翻译模型，包含三字符组支持 |
| C++11 | 引入原始字符串字面量、用户定义字面量；UTF-8 字符支持 |
| C++14 | 预处理数字允许单引号作为数字分隔符 |
| C++17 | 弃用三字符组（Trigraph） |
| C++20 | 引入模块（Modules）相关的预处理记号 |
| C++23 | 移除三字符组；重构 UTF-8 支持；新增翻译字符集概念 |

### 设计动机

翻译阶段的划分旨在：

1. **标准化编译过程**：确保不同编译器产生一致的翻译结果
2. **支持分离编译**：翻译单元可独立编译后再链接
3. **支持模板机制**：阶段 8 专门处理模板实例化
4. **国际化支持**：通过多阶段的字符集处理支持多种编码

### C++ 与 C 翻译阶段的差异

| 特性 | C++ | C |
|------|-----|---|
| 阶段数量 | 9 个 | 8 个 |
| 模板实例化 | 阶段 8（C++ 特有） | 无 |
| 原始字符串 | C++11 起支持 | 不支持 |
| 用户定义字面量 | C++11 起支持 | 不支持 |
| 模块 | C++20 起支持 | 不支持 |
| 三字符组 | C++17 弃用，C++23 移除 | C23 移除 |

### 三字符组的历史

三字符组（Trigraph）用于解决某些键盘无法输入特定字符的问题：

```
??=  →  #      ??(  →  [      ??/  →  \
??)  →  ]      ??'  →  ^      ??<  →  {
??>  →  }      ??!  →  |      ??-  →  ~
```

C++17 将其标记为弃用，C++23 完全移除。

## 3. 语法与参数（Syntax and Parameters）

### 预处理记号（Preprocessing Tokens）

预处理记号是翻译阶段 3-6 中的最小词法元素。

**分类**：

| 类型 | 示例 | 说明 |
|------|------|------|
| 头文件名 | `<iostream>`、`"myfile.h"` | 仅在特定上下文中识别 |
| 占位记号 | `import XXX;`、`module XXX;` | C++20 起，模块相关 |
| 标识符 | `main`、`std::cout` | 变量名、函数名等 |
| 预处理数字 | `123`、`3.14`、`0xE+foo` | 可能无效，后续验证 |
| 字符字面量 | `'a'`、`u8'中'` | C++11 起支持用户定义 |
| 字符串字面量 | `"hello"`、`R"(raw)"` | C++11 起支持用户定义 |
| 运算符和标点 | `+`、`<<=`、`<%`、`##` | 包括替代表示 |
| 其他非空白字符 | 不符合其他类别 | 某些情况导致程序非法 |

**非法字符**：如果单个非空白字符是以下之一，程序非法：
- 单引号 `'`（U+0027）
- 双引号 `"`（U+0022）
- 不在基本字符集中的字符

### 预处理数字

预处理数字是整数和浮点字面量记号的超集：

```
.(可选) 数字 pp-continue-seq(可选)
```

**pp-continue 的组成**：

| 组成 | 说明 |
|------|------|
| `identifier-continue` | 有效标识符的非首字符 |
| `exp-char sign-char` | 指数部分：`P/p/E/e` 后跟 `+/-` |
| `.` | 小数点 |
| `' 数字` | C++14 起：数字分隔符 |
| `' 非数字` | C++14 起：数字分隔符 |

### 记号（Tokens）

记号是翻译阶段 7 中的最小词法元素：

| 类型 | 示例 |
|------|------|
| 标识符 | `main`、`vector` |
| 关键字 | `int`、`class`、`template` |
| 字面量 | `42`、`3.14`、`"hello"` |
| 运算符和标点 | `+`、`<<=`、`;`（不包括预处理运算符） |

### 阶段 1：源字符映射

**处理内容**：
1. 将源文件字节映射到基本源字符集
2. 替换操作系统相关的行结束符为换行符
3. 无法映射的字符替换为通用字符名（`\u` 或 `\U`）
4. 三字符组替换（C++17 前）

**基本源字符集**：96 个字符（与 C 相同）

**C++23 UTF-8 文件处理**：
- 必须支持 UTF-8 输入文件
- UTF-8 文件解码为 Unicode 标量值序列
- CR+LF 和单独 CR 替换为 LF

### 阶段 2：行拼接

**处理规则**：
1. 删除 BOM（字节顺序标记，C++23 起）
2. 行尾反斜杠 `\` 后跟换行符时，删除两者，合并物理行
3. 单次扫描操作：两个反斜杠不合并三行
4. 非空文件不以换行符结尾时，添加终止换行符

### 阶段 3：词法分析

**处理内容**：
1. 将源文件分解为预处理记号和空白
2. 原始字符串字面量的特殊处理（C++11 起）
3. 通用字符名识别和替换（C++23 起）
4. 注释替换为单个空格，换行符保留

**非法情况**：
- 源文件以部分预处理记号结尾（如不完整的字符串）
- 源文件以部分注释结尾

### 阶段 4：预处理

**处理内容**：
1. 执行预处理器
2. 处理 `#include` 指令（递归执行阶段 1-4）
3. 移除所有预处理指令

### 阶段 5：确定字符串字面量编码

**处理内容**：
1. 字符和字符串字面量转换为字面量编码
2. 转义序列和通用字符名展开
3. 相邻字符串字面量确定公共编码前缀（C++23 前）

### 阶段 6：字符串拼接

**处理内容**：
- 相邻的字符串字面量被拼接

### 阶段 7：编译

**处理内容**：
- 预处理记号转换为记号
- 语法和语义分析
- 形成翻译单元

### 阶段 8：模板实例化

**处理内容**：
- 检查翻译单元，生成所需模板实例化列表
- 定位模板定义，执行实例化
- 产生实例化单元

### 阶段 9：链接

**处理内容**：
- 收集翻译单元、实例化单元和库组件
- 解析外部引用
- 生成程序映像

## 4. 底层原理（Underlying Principles）

### 最大匹配原则（Maximal Munch）

解析预处理记号时，总是选择能构成有效记号的**最长字符序列**：

```cpp
int foo = 1;
int bar = 0xE+foo;   // 错误：解析为预处理数字 "0xE+foo"，无效
int baz = 0xE + foo; // 正确：显式分隔
```

**多字符运算符优先**：
```cpp
int num1 = foo+++++bar; // 错误：解析为 "foo++ ++ +bar"
int num2 = -----foo;    // 错误：解析为 "-- -- -foo"
```

### 最大匹配原则的例外

**例外 1：头文件名仅在特定位置识别**

```cpp
std::vector<int> x;  // 正确："int" 不被识别为头文件名
```

头文件名仅在以下位置识别：
- `#include` 指令中的 `include` 后
- `__has_include` 表达式中（C++17 起）
- `import` 指令中的 `import` 后（C++20 起）

**例外 2：`<::` 特殊处理**

如果接下来三个字符是 `<::` 且后续字符不是 `:` 或 `>`，则 `<` 单独作为记号：

```cpp
std::vector<::Foo> x;  // 正确：<: 不被当作 [ 的替代表示
extern int y<::>;      // 正确：等价于 "extern int y[];"
int z<:::Foo::value:>; // 正确：等价于 "int z[::Foo::value];"
```

**例外 3：`>>` 在模板中的处理**

如果两个 `>` 中的一个可以完成模板标识符，则单独处理：

```cpp
Y<X<1>> x3;      // 正确：声明类型为 "Y<X<1>>" 的变量 x3
Y<X<6>>1>> x4;   // 语法错误
Y<X<(6>>1)>> x5; // 正确：使用括号
```

**例外 4：原始字符串优先（C++11 起）**

如果字符序列可能匹配原始字符串前缀和起始双引号，则作为原始字符串处理：

```cpp
#define R "x"
const char* s = R"y";         // 错误：原始字符串字面量，而非 "x" "y"
const char* s2 = R"(a)" "b)"; // 正确：原始字符串后跟普通字符串
```

### 模板实例化机制

阶段 8 的模板实例化是 C++ 特有的：

```
翻译单元 → [检查所需实例化] → 实例化列表
         → [定位模板定义] → 执行实例化
         → 实例化单元
```

**实现差异**：
- 部分编译器不实现实例化单元，而是在阶段 7 编译时实例化
- 链接器负责合并重复的实例化

### 字符编码控制

编译器选项控制阶段 5 的编码转换：

| 编译器 | 源字符集选项 | 执行字符集选项 |
|--------|--------------|----------------|
| GCC/Clang | `-finput-charset` | `-fexec-charset`、`-fwide-exec-charset` |
| MSVC | `/source-charset` | `/execution-charset` |

## 5. 使用场景（Use Cases）

### 行拼接的实际应用

```cpp
// 长宏定义
#define ASSERT_MSG(cond, msg) \
    do {                      \
        if (!(cond)) {        \
            std::cerr << msg; \
            std::abort();     \
        }                     \
    } while(0)

// 长字符串
const char* text = "This is a very long string that "
                   "spans multiple lines.";
```

### 原始字符串字面量的特殊处理

原始字符串的内容在阶段 3 不进行转义处理：

```cpp
#include <iostream>

int main() {
    // 普通字符串需要双重转义
    std::cout << "Path: C:\\Users\\name\n";

    // 原始字符串无需转义
    std::cout << R"(Path: C:\Users\name)" << "\n";

    // 包含引号的原始字符串
    std::cout << R"(He said "Hello")" << "\n";

    return 0;
}
```

### 数字分隔符（C++14 起）

```cpp
// 使用单引号作为数字分隔符，提高可读性
int million = 1'000'000;
int binary = 0b1111'0000'1111'0000;
double pi = 3.141'592'653'589'793;
```

### 替代表示

某些运算符有替代表示，用于键盘无法输入的情况：

| 替代表示 | 标准表示 |
|----------|----------|
| `<%` | `{` |
| `%>` | `}` |
| `<:` | `[` |
| `:>` | `]` |
| `%:` | `#` |
| `%:%:` | `##` |
| `and` | `&&` |
| `or` | `\|\|` |
| `not` | `!` |
| `bitand` | `&` |
| `bitor` | `\|` |
| `xor` | `^` |
| `compl` | `~` |
| `and_eq` | `&=` |
| `or_eq` | `\|=` |
| `xor_eq` | `^=` |
| `not_eq` | `!=` |

### 常见陷阱

**陷阱 1：最大匹配导致解析错误**

```cpp
// 错误：解析为 a++ ++ +b，语法错误
auto x = a+++++b;

// 正确：显式添加空格
auto x = a++ + ++b;
```

**陷阱 2：嵌套模板的 `>>` 问题（C++11 前）**

```cpp
// C++03 错误：>> 被解析为右移运算符
std::vector<std::vector<int>> matrix;

// C++03 正确：需要添加空格
std::vector<std::vector<int> > matrix;

// C++11 起：正确，>> 会正确处理
std::vector<std::vector<int>> matrix;
```

**陷阱 3：全局作用域与替代表示冲突**

```cpp
// C++11 前：错误：<: 被解析为 [
std::vector<::std::string> v;

// C++11 起：正确：<:: 有特殊处理
std::vector<::std::string> v;
```

## 6. 代码示例（Examples）

### 行拼接示例

```cpp
#include <iostream>

#define PRINT_VAR(var) \
    std::cout << #var << " = " << (var) << std::endl

int main() {
    int value = 42;
    PRINT_VAR(value);

    // 行拼接在阶段 2，早于注释处理（阶段 3）
    // 因此反斜杠可以延续跨行
    int x = 1 + \
            2 + \
            3;
    std::cout << "x = " << x << std::endl;

    return 0;
}
```

**输出**：
```
value = 42
x = 6
```

### 最大匹配原则示例

```cpp
#include <iostream>

int main() {
    int foo = 1;
    int bar = 2;

    // 正确：显式空格分隔
    int a = foo++ + ++bar;
    std::cout << "a = " << a << std::endl;  // 1 + 3 = 4

    // 错误：最大匹配导致语法错误
    // int b = foo+++++bar;  // 解析为 foo++ ++ +bar

    // 正确：使用括号或空格
    int c = (foo++) + (++bar);
    std::cout << "c = " << c << std::endl;

    return 0;
}
```

### 原始字符串字面量示例（C++11 起）

```cpp
#include <iostream>

int main() {
    // 普通字符串中的转义
    std::string path1 = "C:\\Users\\Documents\\file.txt";
    std::cout << path1 << std::endl;

    // 原始字符串，无需转义反斜杠
    std::string path2 = R"(C:\Users\Documents\file.txt)";
    std::cout << path2 << std::endl;

    // 包含换行符的原始字符串
    std::string multiline = R"(Line 1
Line 2
Line 3)";
    std::cout << multiline << std::endl;

    // 自定义分隔符（避免括号冲突）
    std::string json = R"json({"key": "value with )" parenthesis"})json";
    std::cout << json << std::endl;

    return 0;
}
```

### 模板实例化示例

```cpp
#include <iostream>

// 模板定义
template<typename T>
class Container {
public:
    T value;
    void print() { std::cout << value << std::endl; }
};

// 显式实例化声明
extern template class Container<int>;

int main() {
    // 隐式实例化
    Container<double> d;
    d.value = 3.14;
    d.print();

    // 使用显式实例化
    Container<int> i;
    i.value = 42;
    i.print();

    return 0;
}
```

### 字符串拼接示例

```cpp
#include <iostream>

int main() {
    // 阶段 6：字符串字面量拼接
    const char* str1 = "Hello, " "World!";

    // 等价于
    const char* str2 = "Hello, World!";

    // 跨行拼接
    const char* long_str = "This is a very long string "
                           "that spans multiple lines "
                           "for readability.";

    std::cout << str1 << std::endl;
    std::cout << long_str << std::endl;

    return 0;
}
```

### 常见错误：文件末尾换行

```cpp
/* 文件内容（无末尾换行） */
int main() { return 0; }/* 无换行结束 */
```

**说明**：C++11 前，非空源文件不以换行符结尾是未定义行为。C++11 起，编译器会自动添加终止换行符。

## 7. 总结（Summary）

### 核心要点

1. **9 个翻译阶段**：从源文件到可执行程序的标准处理流程
2. **预处理记号与记号**：阶段 3-6 使用预处理记号，阶段 7 使用记号
3. **最大匹配原则**：解析时选择最长有效序列，但有特定例外
4. **模板实例化**：阶段 8 是 C++ 特有的，支持模板机制

### 阶段关键操作

| 阶段 | 关键操作 | 重要影响 |
|------|----------|----------|
| 1 | 字符映射 | UTF-8 支持（C++23）、三字符组（已移除） |
| 2 | 行拼接 | 支持宏跨行、BOM 处理（C++23） |
| 3 | 词法分析 | 注释→空格、原始字符串特殊处理 |
| 4 | 预处理 | 宏展开、文件包含、模块处理 |
| 5 | 编码转换 | 源编码→字面量编码 |
| 6 | 字符串拼接 | 相邻字符串合并 |
| 7 | 编译 | 语法语义分析 |
| 8 | 模板实例化 | C++ 特有阶段 |
| 9 | 链接 | 解析外部引用 |

### 与 C 语言对比

| 特性 | C++ | C |
|------|-----|---|
| 阶段数量 | 9 | 8 |
| 模板实例化 | 阶段 8 | 无 |
| 原始字符串 | C++11 起 | 无 |
| 用户定义字面量 | C++11 起 | 无 |
| 数字分隔符 | C++14 起 | C23 起 |
| 模块 | C++20 起 | 无 |

### 学习建议

1. 理解各阶段的顺序和处理内容
2. 掌握最大匹配原则及其例外情况
3. 注意模板相关的特殊处理
4. 了解 C++23 的 UTF-8 和字符集变更
5. 避免使用已弃用/移除的三字符组

### 参考资料

- C++23 标准 (ISO/IEC 14882:2024): 5.2 Phases of translation [lex.phases]
- C++20 标准 (ISO/IEC 14882:2020): 5.2 Phases of translation [lex.phases]
- C++17 标准 (ISO/IEC 14882:2017): 5.2 Phases of translation [lex.phases]
- C++14 标准 (ISO/IEC 14882:2014): 2.2 Phases of translation [lex.phases]
- C++11 标准 (ISO/IEC 14882:2011): 2.2 Phases of translation [lex.phases]
- C++03 标准 (ISO/IEC 14882:2003): 2.1 Phases of translation [lex.phases]
- C++98 标准 (ISO/IEC 14882:1998): 2.1 Phases of translation [lex.phases]